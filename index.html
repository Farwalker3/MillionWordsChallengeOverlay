<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Million Words Challenge Overlay</title>

  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    // worker loader for pdf.js
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
  </script>

  <style>
    html,body { height:100%; margin:0; padding:0; background:#0b0b0b; color:#eee; font-family:Inter,Arial,sans-serif; overflow:hidden; }
    #main-container { width:100vw; height:100vh; display:flex; flex-direction:row; }
    /* Game board - left side 60% */
    #game-board { width:60%; height:100%; background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); position:relative; display:flex; flex-direction:column; border-right:3px solid #0f3460; }
    #game-header { padding:0.4rem 1rem; text-align:center; background:rgba(0,0,0,0.3); border-bottom:2px solid #0f3460; }
    #game-title { font-size:1.2rem; font-weight:bold; color:#e94560; margin:0; text-shadow:2px 2px 4px rgba(0,0,0,0.5); }
    #game-stats { display:flex; justify-content:space-around; margin-top:0.3rem; font-size:0.75rem; }
    .stat-box { background:rgba(0,0,0,0.4); padding:0.3rem 0.6rem; border-radius:4px; border:1px solid #0f3460; font-size:0.75rem; }
    #board-container { flex:1; display:flex; align-items:center; justify-content:center; padding:0.5rem; position:relative; }
    #board-grid { display:grid; gap:2px; background:#0a0a0a; padding:4px; border-radius:8px; box-shadow:0 4px 20px rgba(0,0,0,0.8); }
    .board-cell { background:#1e3a5f; border:1px solid #2d5a8a; display:flex; align-items:center; justify-content:center; position:relative; font-size:0.8rem; font-weight:bold; color:#fff; }
    .board-cell.special { background:#3a5f1e; border-color:#5a8a2d; }
    .board-cell.start { background:#5f1e3a; border-color:#8a2d5a; }
    .player-piece { width:80%; height:80%; border-radius:50%; background:#e94560; border:2px solid #fff; box-shadow:0 2px 8px rgba(233,69,96,0.6); display:flex; align-items:center; justify-content:center; font-size:1.2rem; }
    #leaderboard { padding:0.5rem; background:rgba(0,0,0,0.3); border-top:2px solid #0f3460; max-height:20%; overflow-y:auto; }
    #leaderboard h3 { margin:0 0 0.3rem 0; font-size:0.85rem; color:#e94560; }
    .leaderboard-entry { display:flex; justify-content:space-between; padding:0.3rem 0.5rem; margin:0.2rem 0; background:rgba(15,52,96,0.3); border-radius:4px; font-size:0.85rem; }
    /* Slideshow - right side 40% */
    #slideshow-container { width:40%; height:100%; display:flex; align-items:center; justify-content:center; background:#000; }
    .section { width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; padding:1rem; box-sizing:border-box; }
    .pdf-image { max-width:95%; max-height:95%; box-shadow:0 8px 30px rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.06); }
    #ad-box { position:absolute; bottom:18px; right:18px; background:rgba(0,0,0,0.6); padding:.9rem 1.1rem; border-radius:8px; border:1px solid rgba(255,255,255,0.04); font-size:1rem; }
    /* debug panel */
    #debug-panel { display:none; position:fixed; top:10px; left:10px; background:#0b0b0b; color:#a8f0a8; padding:12px; border-radius:6px; border:1px solid #333; z-index:9999; width:320px; max-height:78vh; overflow:auto; font-family:monospace; font-size:13px; }
    #debug-panel h3 { margin:0 0 .5rem 0; font-size:14px; }
    #debug-log { margin-top:.5rem; max-height:36vh; overflow:auto; background:#050505; padding:.4rem; border-radius:4px; border:1px solid #222; }
    .dbg-btn { margin-top:.5rem; display:inline-block; padding:.3rem .5rem; background:#111; color:#bfffbf; border:1px solid #2b2; border-radius:4px; cursor:pointer; }
    input[type=number]{ width:72px; padding:.2rem; margin-left:.5rem; background:#111; color:#bfbfbf; border:1px solid #333; border-radius:4px; }
  </style>
</head>
<body>

  <div id="main-container">
    <!-- Game Board Section -->
    <div id="game-board">
      <div id="game-header">
        <h1 id="game-title">Million Words Challenge</h1>
        <div id="game-stats">
          <div class="stat-box">üìä Progress: <span id="progress-points">0</span></div>
          <div class="stat-box">üé≤ Mode: <span id="game-mode">Starter</span></div>
          <div class="stat-box">üí¨ Total Words: <span id="total-words">0</span></div>
        </div>
      </div>
      
      <div id="board-container">
        <div id="board-grid"></div>
      </div>
      
      <div id="leaderboard">
        <h3>üìù Top Word Contributors</h3>
        <div id="leaderboard-list"></div>
      </div>
    </div>
    
    <!-- Slideshow Section -->
    <div id="slideshow-container">
    <!-- initial fallback content -->
    <div class="section">
      <h1>Million Words Challenge</h1>
      <h2>Begins January 1, 2026</h2>
      <p>Write one million words before January 1, 2027.</p>
      <p>Prizes ‚Ä¢ Publishing Help ‚Ä¢ Community Features</p>
      <p>Donate to support writers and creative projects.</p>
    </div>
    </div>
  </div>

  <div id="ad-box">Your work could be shown here ‚Äî submit PDFs or markdown for rotation!</div>

  <!-- Hidden Debug Panel (toggle with Ctrl+Shift+D) -->
  <div id="debug-panel" aria-hidden="true">
    <h3>Debug</h3>
    <div>
      Rotation speed (minutes):
      <input id="debug-speed" type="number" min="0.1" step="0.1" value="10">
      <button id="apply-speed" class="dbg-btn">Apply</button>
      <button id="skip-next" class="dbg-btn">Next</button>
      <button id="skip-prev" class="dbg-btn">Prev</button>
      <button id="reload-assets" class="dbg-btn">Reload</button>
    </div>
    <div style="margin-top:0.5rem;">
      <button id="reset-game" class="dbg-btn" style="background:#331111;border-color:#822;">üîÑ Reset Game</button>
    </div>
    <hr style="border:none;border-top:1px solid #222;margin:.5rem 0;">
    <div id="debug-log"></div>
  </div>

  <script>
  // ======= GAME BOARD SYSTEM =======
  (function() {
    const BOARD_SIZE = 10; // 10x10 grid
    const TWITCH_CHANNEL = 'farwalker3';
    
    // Game state
    const gameState = {
      position: 0,
      progressPoints: 0,
      totalWords: 0,
      gameMode: 'Starter',
      diceType: 6,
      wordCounts: {}, // username -> word count
      board: []
    };
    
    // Game modes with different dice types (Mario Party style)
    const GAME_MODES = [
      { name: 'Starter', dice: 6, minProgress: 0 },
      { name: 'Explorer', dice: 8, minProgress: 1000 },
      { name: 'Adventurer', dice: 10, minProgress: 5000 },
      { name: 'Hero', dice: 12, minProgress: 15000 },
      { name: 'Legend', dice: 20, minProgress: 50000 }
    ];
    
    // Sound effects (using Web Audio API)
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    function playSound(type) {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      if (type === 'roll') {
        oscillator.frequency.value = 440;
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.3);
      } else if (type === 'move') {
        oscillator.frequency.value = 523;
        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.15);
      } else if (type === 'special') {
        oscillator.frequency.value = 659;
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
      }
    }
    
    // Initialize board
    function initBoard() {
      const total = BOARD_SIZE * BOARD_SIZE;
      gameState.board = [];
      for (let i = 0; i < total; i++) {
        const isSpecial = i > 0 && (i % 10 === 0 || i % 15 === 0);
        gameState.board.push({
          index: i,
          special: isSpecial,
          bonus: isSpecial ? Math.floor(Math.random() * 50) + 50 : 0
        });
      }
    }
    
    // Render board
    function renderBoard() {
      const boardGrid = document.getElementById('board-grid');
      boardGrid.style.gridTemplateColumns = `repeat(${BOARD_SIZE}, 1fr)`;
      boardGrid.style.gridTemplateRows = `repeat(${BOARD_SIZE}, 1fr)`;
      boardGrid.style.width = '500px';
      boardGrid.style.height = '500px';
      
      boardGrid.innerHTML = '';
      gameState.board.forEach((cell, idx) => {
        const cellDiv = document.createElement('div');
        cellDiv.className = 'board-cell';
        if (idx === 0) cellDiv.classList.add('start');
        if (cell.special) cellDiv.classList.add('special');
        
        if (idx === gameState.position) {
          const piece = document.createElement('div');
          piece.className = 'player-piece';
          piece.textContent = 'üéØ';
          cellDiv.appendChild(piece);
        }
        
        if (cell.special && cell.bonus > 0) {
          cellDiv.textContent = `+${cell.bonus}`;
        } else if (idx === 0) {
          cellDiv.textContent = 'START';
        }
        
        boardGrid.appendChild(cellDiv);
      });
    }
    
    // Update game mode based on progress
    function updateGameMode() {
      for (let i = GAME_MODES.length - 1; i >= 0; i--) {
        if (gameState.progressPoints >= GAME_MODES[i].minProgress) {
          if (gameState.gameMode !== GAME_MODES[i].name) {
            gameState.gameMode = GAME_MODES[i].name;
            gameState.diceType = GAME_MODES[i].dice;
            playSound('special');
            log(`üéâ Level Up! Now in ${gameState.gameMode} mode with d${gameState.diceType}!`);
          }
          break;
        }
      }
    }
    
    // Update UI stats
    function updateStats() {
      document.getElementById('progress-points').textContent = gameState.progressPoints.toLocaleString();
      document.getElementById('game-mode').textContent = gameState.gameMode;
      document.getElementById('total-words').textContent = gameState.totalWords.toLocaleString();
      updateGameMode();
    }
    
    // Update leaderboard
    function updateLeaderboard() {
      const leaderboardList = document.getElementById('leaderboard-list');
      const sorted = Object.entries(gameState.wordCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);
      
      leaderboardList.innerHTML = sorted.map(([user, count], idx) => {
        const medals = ['ü•á', 'ü•à', 'ü•â'];
        const medal = medals[idx] || 'üèÖ';
        return `<div class="leaderboard-entry"><span>${medal} ${user}</span><span>${count} words</span></div>`;
      }).join('');
    }
    
    // Roll dice and move
    function rollDice(username) {
      const roll = Math.floor(Math.random() * gameState.diceType) + 1;
      playSound('roll');
      log(`üé≤ ${username} rolled a ${roll}!`);
      
      // Animate movement
      let steps = 0;
      const moveInterval = setInterval(() => {
        if (steps < roll) {
          gameState.position = (gameState.position + 1) % gameState.board.length;
          playSound('move');
          renderBoard();
          steps++;
        } else {
          clearInterval(moveInterval);
          
          // Check for special space
          const currentCell = gameState.board[gameState.position];
          if (currentCell.special) {
            gameState.progressPoints += currentCell.bonus;
            playSound('special');
            log(`‚ú® Bonus! +${currentCell.bonus} progress points!`);
          }
          
          // Base progress from movement
          gameState.progressPoints += roll * 10;
          
          updateStats();
          saveGameState();
        }
      }, 200);
    }
    
    // Twitch IRC connection
    let ws = null;
    
    function connectTwitch() {
      ws = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
      
      ws.onopen = () => {
        ws.send('PASS SCHMOOPIIE');
        ws.send('NICK justinfan12345');
        ws.send(`JOIN #${TWITCH_CHANNEL}`);
        log(`‚úÖ Connected to Twitch chat: #${TWITCH_CHANNEL}`);
      };
      
      ws.onmessage = (event) => {
        const message = event.data;
        
        // Handle PING
        if (message.startsWith('PING')) {
          ws.send('PONG :tmi.twitch.tv');
          return;
        }
        
        // Parse chat message
        const match = message.match(/:(\w+)!.*PRIVMSG #\w+ :(.+)/);
        if (match) {
          const username = match[1];
          const text = match[2].trim();
          
          // Count words
          const wordCount = text.split(/\s+/).filter(w => w.length > 0).length;
          gameState.wordCounts[username] = (gameState.wordCounts[username] || 0) + wordCount;
          gameState.totalWords += wordCount;
          
          updateStats();
          updateLeaderboard();
          saveGameState();
          
          // Check for !roll command
          if (text.toLowerCase().startsWith('!roll')) {
            rollDice(username);
          }
        }
      };
      
      ws.onerror = (error) => {
        log('‚ùå Twitch connection error');
        console.error(error);
      };
      
      ws.onclose = () => {
        log('‚ö†Ô∏è Twitch connection closed. Reconnecting in 5s...');
        setTimeout(connectTwitch, 5000);
      };
    }
    
    // Save/Load game state
    function saveGameState() {
      localStorage.setItem('mwc_gameState', JSON.stringify(gameState));
    }
    
    function loadGameState() {
      const saved = localStorage.getItem('mwc_gameState');
      if (saved) {
        const loaded = JSON.parse(saved);
        Object.assign(gameState, loaded);
        log('üìÅ Game state loaded from localStorage');
      }
    }
    
    function resetGameState() {
      if (confirm('‚ö†Ô∏è Reset all game progress? This cannot be undone!')) {
        gameState.position = 0;
        gameState.progressPoints = 0;
        gameState.totalWords = 0;
        gameState.gameMode = 'Starter';
        gameState.diceType = 6;
        gameState.wordCounts = {};
        saveGameState();
        updateStats();
        updateLeaderboard();
        renderBoard();
        log('üîÑ Game state reset!');
      }
    }
    
    // Logging
    function log(message) {
      console.log(message);
      const debugLog = document.getElementById('debug-log');
      if (debugLog) {
        const time = new Date().toLocaleTimeString();
        debugLog.innerHTML += `<div>[${time}] ${message}</div>`;
        debugLog.scrollTop = debugLog.scrollHeight;
      }
    }
    
    // Initialize game
    function initGame() {
      loadGameState();
      initBoard();
      renderBoard();
      updateStats();
      updateLeaderboard();
      connectTwitch();
      log('üéÆ Game initialized!');
      
      // Expose reset function globally for debug panel
      window.resetGame = resetGameState;
    }
    
    // Start when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initGame);
    } else {
      initGame();
    }
  })();
  
  // ======= SLIDESHOW SYSTEM =======
  (function () {
    // ======= CONFIG =======
    // Folders to scan ‚Äî they must contain a manifest.json listing filenames
    const FOLDERS = ['pro/', 'personal/', 'community/'];

    // default rotation interval (minutes -> ms)
    let rotationInterval = 10 * 60 * 1000;
    let intervalId = null;

    // If you want to limit pages per PDF for performance, set a page cap:
    const PDF_PAGE_LIMIT = 200; // set high or lower if you want to limit

    // UI elements
    const main = document.getElementById('slideshow-container');
    const debugPanel = document.getElementById('debug-panel');
    const debugLog = document.getElementById('debug-log');
    const speedInput = document.getElementById('debug-speed');
    const applySpeedBtn = document.getElementById('apply-speed');
    const skipNextBtn = document.getElementById('skip-next');
    const skipPrevBtn = document.getElementById('skip-prev');
    const reloadBtn = document.getElementById('reload-assets');
    const resetGameBtn = document.getElementById('reset-game');

    // Slide store
    let slides = []; // { type: 'image', url: '...' } where url may be dataURL or remote url
    let currentIndex = 0;

    // Logging helper
    function dbg(msg) {
      try {
        const d = new Date().toLocaleTimeString();
        const line = document.createElement('div');
        line.textContent = `[${d}] ${msg}`;
        debugLog.appendChild(line);
        debugLog.scrollTop = debugLog.scrollHeight;
        console.log(msg);
      } catch(e) {
        console.log('dbg error', e);
      }
    }

    // Toggle debug panel with Ctrl+Shift+D
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'd') {
        debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
      }
    });

    applySpeedBtn.addEventListener('click', () => {
      const minutes = parseFloat(speedInput.value);
      if (!isNaN(minutes) && minutes > 0) {
        rotationInterval = Math.max(100, minutes * 60 * 1000);
        dbg(`Rotation speed set to ${minutes} minutes (${rotationInterval} ms)`);
        restartInterval();
      } else {
        dbg('Invalid speed value');
      }
    });

    skipNextBtn.addEventListener('click', () => { showNext(); });
    skipPrevBtn.addEventListener('click', () => { showPrev(); });
    reloadBtn.addEventListener('click', () => { loadAndStart(); });
    if (resetGameBtn) {
      resetGameBtn.addEventListener('click', () => { 
        if (typeof window.resetGame === 'function') {
          window.resetGame();
        }
      });
    }

    // Shuffle (Fisher-Yates)
    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // Load a manifest.json from a folder. Manifest should be a JSON array of filenames, e.g.:
    // ["page1.png","page2.png","doc.pdf"]
    async function loadManifest(folder) {
      const url = folder + 'manifest.json';
      try {
        const res = await fetch(url, {cache: "no-store"});
        if (!res.ok) {
          dbg(`No manifest at ${url} (HTTP ${res.status})`);
          return [];
        }
        const list = await res.json();
        if (!Array.isArray(list)) {
          dbg(`Manifest ${url} is not an array`);
          return [];
        }
        return list.map(name => folder + name);
      } catch (err) {
        dbg(`Error loading manifest ${url}: ${err}`);
        return [];
      }
    }

    // Render a single PDF page with pdf.js and return a dataURL
    async function renderPDFPage(url, pageNum, scale=1.5) {
      const pdf = await pdfjsLib.getDocument(url).promise;
      const page = await pdf.getPage(pageNum);
      const viewport = page.getViewport({ scale });
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = Math.ceil(viewport.width);
      canvas.height = Math.ceil(viewport.height);
      await page.render({ canvasContext: ctx, viewport }).promise;
      const dataURL = canvas.toDataURL('image/png');
      return dataURL;
    }

    // Convert a PDF URL to image slides (data URLs). Capped by PDF_PAGE_LIMIT.
    async function convertPDFToSlides(pdfUrl) {
      dbg(`Converting PDF: ${pdfUrl}`);
      try {
        const pdfDoc = await pdfjsLib.getDocument(pdfUrl).promise;
        const total = Math.min(pdfDoc.numPages, PDF_PAGE_LIMIT);
        const out = [];
        for (let p = 1; p <= total; p++) {
          dbg(`Rendering ${pdfUrl} page ${p}/${total}`);
          const page = await pdfDoc.getPage(p);
          const viewport = page.getViewport({ scale: 1.4 });
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = Math.ceil(viewport.width);
          canvas.height = Math.ceil(viewport.height);
          await page.render({ canvasContext: ctx, viewport }).promise;
          out.push({ type: 'image', url: canvas.toDataURL('image/png'), source: pdfUrl, page: p });
        }
        dbg(`Finished converting ${pdfUrl} (${out.length} pages)`);
        return out;
      } catch (err) {
        dbg(`Error converting PDF ${pdfUrl}: ${err}`);
        return [];
      }
    }

    // Build slides from manifests (images and PDFs)
    async function buildSlidesFromFolders() {
      slides = [];
      for (const folder of FOLDERS) {
        dbg(`Loading manifest for folder: ${folder}`);
        const entries = await loadManifest(folder); // returns full paths
        if (!entries.length) continue;
        for (const item of entries) {
          const lower = item.toLowerCase();
          if (lower.endsWith('.pdf')) {
            // convert to slides (each page -> image)
            const converted = await convertPDFToSlides(item);
            slides.push(...converted);
          } else if (lower.endsWith('.png') || lower.endsWith('.jpg') || lower.endsWith('.jpeg') || lower.endsWith('.webp') || lower.endsWith('.gif')) {
            slides.push({ type: 'image', url: item, source: folder, page: null });
          } else {
            dbg(`Skipping unsupported file type: ${item}`);
          }
        }
      }

      // Add the challenge splash as a stable text first element so it is guaranteed to be shown at least once:
      const challengeSlide = {
        type: 'text',
        html: `
          <div class="section">
            <h1>Million Words Challenge</h1>
            <h2>Begins January 1, 2026</h2>
            <p>Write one million words before January 1, 2027.</p>
            <p>Prizes ‚Ä¢ Publishing Help ‚Ä¢ Community Features</p>
            <p>Donate to support writers and creative projects.</p>
          </div>`
      };

      // Mixed/shuffled: include challengeSlide and then shuffle the rest
      const rest = shuffleArray(slides.slice());
      slides = [challengeSlide, ...rest];
      dbg(`Built slides. Total slides (including challenge): ${slides.length}`);
    }

    // Render the current slide
    function renderCurrent() {
      if (!slides || !slides.length) {
        main.innerHTML = `<div class="section"><h2>No assets found</h2><p>Add manifest.json files to ${FOLDERS.join(', ')} with images and PDFs.</p></div>`;
        return;
      }
      const s = slides[currentIndex];
      if (!s) return;
      main.innerHTML = '';
      if (s.type === 'text') {
        const wrapper = document.createElement('div');
        wrapper.innerHTML = s.html;
        main.appendChild(wrapper);
      } else if (s.type === 'image') {
        const wrapper = document.createElement('div');
        wrapper.className = 'section';
        const img = document.createElement('img');
        img.className = 'pdf-image';
        img.src = s.url;
        img.alt = s.source ? `${s.source}${s.page ? ' - page ' + s.page : ''}` : 'slide image';
        wrapper.appendChild(img);
        main.appendChild(wrapper);
      }
      dbg(`Displayed slide ${currentIndex+1}/${slides.length}${s.source ? ` (from ${s.source}${s.page ? ', page ' + s.page : ''})` : ''}`);
    }

    function showNext() {
      if (!slides.length) return;
      currentIndex = (currentIndex + 1) % slides.length;
      renderCurrent();
    }
    function showPrev() {
      if (!slides.length) return;
      currentIndex = (currentIndex - 1 + slides.length) % slides.length;
      renderCurrent();
    }

    function startInterval() {
      if (intervalId) clearInterval(intervalId);
      intervalId = setInterval(() => {
        showNext();
      }, rotationInterval);
      dbg(`Interval started: ${rotationInterval} ms`);
    }
    function restartInterval() {
      if (intervalId) clearInterval(intervalId);
      startInterval();
    }

    // Top-level loader
    async function loadAndStart() {
      dbg('Starting loadAndStart()');
      slides = [];
      currentIndex = 0;
      // Build slides
      await buildSlidesFromFolders();
      if (!slides.length) {
        dbg('No slides available.');
        renderCurrent();
        return;
      }
      // Show first slide immediately and start interval
      renderCurrent();
      startInterval();
    }

    // initial run
    loadAndStart();

    // expose some small controls to debug console if needed
    window.__mw_overlay = {
      reload: loadAndStart,
      next: showNext,
      prev: showPrev,
      slidesCount: () => slides.length,
      getSlides: () => slides
    };

  })();
  </script>
</body>
</html>